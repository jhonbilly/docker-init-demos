trigger:
  - main

pool:
  name: wsl-agent

variables:
  dockerRegistryServiceConnection: 'DockerHubServiceConnection'
  imageRepository: 'docker-getting-started'
  containerRegistry: 'jhonbilly'
  tag: '$(Build.BuildId)'
  SONAR_HOST_URL: 'http://172.20.38.158:9000'
  SONAR_PROJECT_KEY: 'docker-getting-started'
  SONAR_TOKEN: 'f4926fec98e5dd8491fd55400c0c167711d23aa2'

stages:
  - stage: AnalyzeAndBuild
    jobs:
      - job: SonarQubeAnalysis
        displayName: 'NPM Install & SonarQube Analysis'
        steps:
          - script: |
              cd node/
              npm install
            displayName: 'NPM Install'

          - script: |
              export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64
              export PATH=$JAVA_HOME/bin:$PATH
              cd node/sample
              sonar-scanner -X \
                -Dsonar.projectKey=$(SONAR_PROJECT_KEY) \
                -Dsonar.sources=. \
                -Dsonar.host.url=$(SONAR_HOST_URL) \
                -Dsonar.login=$(SONAR_TOKEN)
            displayName: 'Run SonarQube Scanner (Local)'
            name: SonarQubeTask
            continueOnError: true   # <-- Esto permite capturar el error

          # Analisis exitoso: Solo corre si SonarQube fue OK
          - script: |
              echo "Análisis SonarQube exitoso, compilando app..."
              cd node/sample
              npm run build || exit 1
            displayName: 'Build app (SonarQube OK)'
            condition: succeeded('SonarQubeTask')

          # Analisis fallido: Solo corre si SonarQube falló
          - script: |
              echo "El análisis SonarQube FALLÓ. Revisar calidad de código antes de continuar."
              exit 1
            displayName: 'Fallo SonarQube, detener pipeline'
            condition: failed('SonarQubeTask')

  - stage: DockerBuildPush
    dependsOn: AnalyzeAndBuild
    condition: succeeded()   # Solo continúa si el stage previo fue exitoso
    jobs:
      - job: DockerImage
        steps:
          - task: Docker@2
            inputs:
              containerRegistry: '$(dockerRegistryServiceConnection)'
              repository: '$(imageRepository)'
              command: 'buildAndPush'
              Dockerfile: 'node/Dockerfile'
              buildContext: '.'
              tags: |
                $(tag)

  - stage: DeployK8s
    dependsOn: DockerBuildPush
    condition: succeeded()   # Solo continúa si el build fue OK
    jobs:
      - deployment: DeployApp
        environment: 'dev'
        strategy:
          runOnce:
            deploy:
              steps:
                - task: HelmInstaller@1
                  inputs:
                    helmVersionToInstall: 'latest'
                - task: HelmDeploy@0
                  inputs:
                    connectionType: 'Kubeconfig'
                    kubeconfig: '$(KUBECONFIG)'
                    command: 'upgrade'
                    chartType: 'FilePath'
                    chartPath: 'helm/docker-getting-started'
                    releaseName: 'getting-started'
                    overrideValues: |
                      image.repository=$(containerRegistry)/$(imageRepository)
                      image.tag=$(tag)
                    install: true
